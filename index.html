<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dymaxion Map</title>
  <style>
    body {
      font-family: sans-serif;
    }
    .no-select {
      -webkit-touch-callout: none; /* iOS Safari */
        -webkit-user-select: none; /* Safari */
         -khtml-user-select: none; /* Konqueror HTML */
           -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
                user-select: none; /* Non-prefixed version, currently
                                      supported by Chrome and Opera */
    }
    .eqr-map {
      position: relative;
      width: 1024px;
      height: 512px;
      border: solid 1px #ccc;
    }
    .eqr-box {
      position: absolute;
      top: 0px;
      left: 0px;
      width: 1024px;
      height: 512px;
    }
    #eqr_info {
      margin-bottom: 7px;
    }
    #eqr_angles {
      margin-left: 20px;
      font-family: monospace;
    }
    #eqr_image {
    }
    #eqr_canvas {
    }

    #dym_info {
      margin-top: 7px;
      margin-bottom: 7px;
    }
    .dym-map {
      position: relative;
      width: 1024px;
      height: 512px;
      border: solid 1px #ccc;
    }
    .dym-box {
      position: absolute;
      top: 0px;
      left: 0px;
      width: 1024px;
      height: 512px;
    }
    #dym_update {
      margin-left: 10px;
    }
  </style>
  <script
    src="https://code.jquery.com/jquery-3.4.1.min.js"
    integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
    crossorigin="anonymous"></script>
</head>

<body>
  <div id="eqr_info">
    <span>Equirectangular Projection</span>
    <span id="eqr_angles">
  </div>
  <div class="eqr-map no-select">
    <img
      id="eqr_image"
      class="eqr-box"
      src="eqr_world_2.png"
    />
    <canvas
      id="eqr_canvas"
      class="eqr-box"
      width="1024"
      height="512"
    ></canvas>
  </div>

  <div id="dym_info">
    <span>Dymaxion Projection</span>
    <button id="dym_update">Update</button>
  </div>
  <div class="dym-map no-select">
    <canvas
      id="dym_canvas"
      class="dym-box"
      width="1024"
      height="512"
    ></canvas>
  </div>

  <script src="utils.js"></script>
  <script src="icosahedron.js"></script>
  <script src="subfaces.js"></script>
  <script>
    var canvasWidth = 1024;
    var canvasHeight = 512;
    var canvasWidth2 = canvasWidth / 2;
    var canvasHeight2 = canvasHeight / 2;
    var canvasPxAz = canvasWidth / (2 * Math.PI);
    var canvasPxEl = canvasHeight / Math.PI;

    function getCanvasPos(azEl) {
      var az = azEl[0];
      var el = azEl[1];
      var x = canvasWidth2 + az * canvasPxAz;
      var y = canvasHeight2 - el * canvasPxEl;
      return [x, y];
    }

    function moveTo(ctx, azEl) {
      p = getCanvasPos(azEl);
      ctx.moveTo(p[0], p[1]);
    }

    function lineTo(ctx, azEl) {
      p = getCanvasPos(azEl);
      ctx.lineTo(p[0], p[1]);
    }

    function drawLine(ctx, p0, p1) {
      // If the line wraps between -pi and pi,
      // draw two lines so that it looks correct
      // TO DO: With small line segments, perhaps
      // don't draw at all?
      
      // Don't draw lines that end at the poles
      if (
        (Math.abs(Math.abs(p0[1]) - Math.PI / 2) < 0.05) ||
        (Math.abs(Math.abs(p1[1]) - Math.PI / 2) < 0.05)
      ) {
        return;
      }

      // Handle lines that wrap between -pi and pi
      // in az axis
      if ((Math.abs(p1[0] - p0[0])) > Math.PI) {
        var sign = (p1[0] < p0[0]) ? 1 : -1;
        moveTo(ctx, p0);
        lineTo(ctx, [p1[0] + sign * 2 * Math.PI, p1[1]]);
        moveTo(ctx, [p0[0] - sign * 2 * Math.PI, p0[1]]);
        lineTo(ctx, p1);
      }
      else {
        moveTo(ctx, p0);
        lineTo(ctx, p1);
      }
    }

    function drawVertex(ctx, azEl) {
      p = getCanvasPos(azEl);
      ctx.moveTo(p[0], p[1]);
      ctx.arc(p[0], p[1], 5, 0, 2 * Math.PI);
    }

    function drawAzElLines(ctx) {
      var azCount = 18;
      var elCount = 10;
      for (var i = 0; i < azCount; i++) {
        var az = -Math.PI + 2 * Math.PI / azCount * i;
        moveTo(ctx, [az, -Math.PI / 2]);
        lineTo(ctx, [az, Math.PI / 2]);
      }
      for (var j = 0; j < elCount; j++) {
        var el = -Math.PI / 2 + Math.PI / elCount * j;
        moveTo(ctx, [-Math.PI, el]);
        lineTo(ctx, [Math.PI, el]);
      }
    }

    function draw(ctx, edgePointsOuter, zAngle, yAngle, xAngle) {
      // Get az-el edge points
      var polarEdgePointsOuter = [];
      for (var j = 0; j < edgePointsOuter.length; j++) {
        var edgePoints = edgePointsOuter[j];
        var polarEdgePoints = [];
        for (var i = 0; i < edgePoints.length; i++) {
          var polarEdgePoint = polar(rotate3d(
            edgePoints[i], zAngle, yAngle, xAngle));
          polarEdgePoints.push([polarEdgePoint[1], polarEdgePoint[2]]);
        }
        polarEdgePointsOuter.push(polarEdgePoints);
      }

      // Draw edge points
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      ctx.beginPath();

      for (var j = 0; j < polarEdgePointsOuter.length; j++) {
        var polarEdgePoints = polarEdgePointsOuter[j];
        for (var i = 0; i < polarEdgePoints.length; i++) {
          // drawVertex(ctx, polarEdgePoints[i]);
          if (i > 0) {
            drawLine(ctx, polarEdgePoints[i - 1], polarEdgePoints[i]);
          }
        }
      }

      ctx.stroke();
    }

    var zAngle = 0;
    var yAngle = 0;  // -0.8 * Math.PI;
    var xAngle = 0;

    function updateUi() {
      $('#eqr_angles').text(
        'xAngle = ' + xAngle.toFixed(4) + ' ' +
        'yAngle = ' + yAngle.toFixed(4) + ' ' +
        'zAngle = ' + zAngle.toFixed(4));
    }

    function testSubfaces() {
      var subfaceData = Subfaces.createSubfaceData({ divisionCount: 8 });
      // console.log(subfaceData);

      // Draw on canvas
      var canvasEl = $('#dym_canvas');
      var ctx = canvasEl.get(0).getContext('2d');
      ctx.beginPath();

      function X(x) { return 20 + 100 * x; }
      function Y(y) { return 512 - 392 - 100 * y; }

      var divCount = subfaceData.subfacesByDivision.length;
      var subvertices = subfaceData.subvertices;
      for (var divIndex = 0; divIndex < divCount; divIndex++) {
        var count = subfaceData.vertexCountsByDivision[divIndex];
        for (var i = 0; i < count; i++) {
          var x = X(subvertices[i][0] + 1.2 * divIndex);
          var y = Y(subvertices[i][1]);
          ctx.moveTo(x, y);
          ctx.arc(x, y, 2, 0, 2 * Math.PI);
        }
      }
      ctx.stroke();
    }

    function main() {
      var canvasEl = $('#eqr_canvas');
      var ctx = canvasEl.get(0).getContext('2d');

      // Get icosahedron vertices
      var vertices = Icosahedron.getVertices();
      var edges = Icosahedron.getEdges();
      var edgePointsOuter = Icosahedron.getEdgePoints(vertices, edges, 20);

      // Change angles when dragging the equirectangular
      // map.
      var DRAG_WEIGHT = 0.001;
      canvasEl.on('mousedown', function(e) {
        var prevPageX = e.pageX;
        var prevPageY = e.pageY;
        canvasEl.on('mouseup mouseout', function(e) {
          // Stop movement
          canvasEl.off('mouseup mouseout mousemove');
        });
        canvasEl.on('mousemove', function(e) {
          // Calculate movement
          var dPageX = e.pageX - prevPageX;
          var dPageY = e.pageY - prevPageY;

          zAngle = wrapAngle(zAngle + dPageX * DRAG_WEIGHT);
          if (e.shiftKey) {
            xAngle = wrapAngle(xAngle + dPageY * DRAG_WEIGHT);
          }
          else {
            yAngle = wrapAngle(yAngle + dPageY * DRAG_WEIGHT);
          }

          prevPageX = e.pageX;
          prevPageY = e.pageY;

          updateUi();
        });
      });

      function drawFrame() {
        draw(ctx, edgePointsOuter, zAngle, yAngle, xAngle);
        // yAngle = wrapAngle(yAngle + 0.003);
        // zAngle = wrapAngle(zAngle + 0.002);
        // xAngle = wrapAngle(xAngle + 0.001);
        window.requestAnimationFrame(drawFrame);
      }
      window.requestAnimationFrame(drawFrame);
      
      updateUi();

      // Draw subfaces and subvertices
      testSubfaces();
    }

    $(document).ready(function() {
      main();
    });

    // Notes:
    // https://stackoverflow.com/questions/35274934/retrieve-image-data-from-file-input-without-a-server

    // TO DO:
    // - Split into separate files
    // - Common drawing utility functions
    //    - Transformation onto canvas
    //    - Line, vertex, polygon, etc
    // - Dymaxion draw face zero
    //    - Colors from eqr map image
    //    - Draw with lots of subfaces

  </script>
</body>

</html>
